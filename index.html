<!DOCTYPE html> 
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Binary Profit Table (Frontend)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer"/>
  <link rel="preconnect" href="https://rsms.me/">
  <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
  <style>
    :root {
      --sidebar-bg:     #0e0e0e;
      --main-bg:        #0e0e0e;
      --header-bg:      #0e0e0e;
      --text-primary:   #ffffff;
      --text-secondary: #cccccc;
      --accent-positive:#00d0b2;
      --accent-negative:#f44336;
      --badge-bg:       #5b8a92;
      --badge-text:     #ffffff;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: Inter, sans-serif;
      font-feature-settings: 'tnum';
      background: var(--main-bg);
      color: var(--text-primary);
      font-size: 14px;
    }
    .container { display: flex; height: 100vh; flex-direction: column; }
    main.main { flex: 1; padding: 20px; display: flex; flex-direction: column; }
    .table-container {
      flex: 1; overflow-y: auto; overflow-x: hidden; scrollbar-width: none;
      background-color: var(--main-bg); max-height: calc(100vh - 50px);
    }
    .table-container::-webkit-scrollbar { display: none; }
    table { width: 100%; border-collapse: collapse; min-width: 900px; }
    thead th {
      position: sticky; top: 0; background: var(--header-bg);
      padding: 12px; color: var(--text-primary); text-align: left;
      font-size: 13px; font-weight: 500;
    }
    tbody td { padding: 12px; color: var(--text-secondary); font-size: 13px; }
    tbody tr:hover td { background: #111; }

    .type-wrap { display:flex; align-items:center; gap:10px; }
    .type-logo {
      width: 1.5cm; height: 1cm;
      max-width: 120px; max-height: 80px;
      display: block; object-fit: contain;
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
    }

    .badge.currency {
      background: var(--badge-bg); color: var(--badge-text);
      padding: 2px 6px; border-radius: 4px; font-size: 11px;
    }
    .time { display:block; color: var(--text-secondary); font-size: 14px; margin-top: 2px; }
    td.positive { color: var(--accent-positive); font-weight: 600; }
    td.negative { color: var(--accent-negative); font-weight: 600; }
    tbody td:nth-child(2),
    tbody td:nth-child(4),
    tbody td:nth-child(5),
    tbody td:nth-child(6),
    tbody td:nth-child(7) {
      color:#eee; font-size:14px; font-weight:500; opacity:.7;
    }
    td:nth-child(8) { font-size:14px; }

    .summary {
      position: sticky; bottom: 0; background: var(--main-bg); z-index: 1;
      margin-top: 10px; display: flex; font-size: 13px; font-weight: 600;
      color: var(--text-secondary); padding: 10px 0 0; border-top: 1px solid #222;
    }
    .summary span:first-child { flex: 7; }
    .summary .total-profit {
      flex: 1; color: var(--accent-positive); font-size: 14px; text-align: left; margin-left: -5.5cm; /* moved 1.5cm right */
    }
  </style>
</head>
<body>
  <div class="container">
    <main class="main">
      <div class="table-container" id="scrollbox">
        <table>
          <thead>
            <tr>
              <th>Type</th>
              <th>Ref. ID</th>
              <th>Currency</th>
              <th>Buy time</th>
              <th>Stake</th>
              <th>Sell time</th>
              <th>Contract value</th>
              <th>Total profit/loss</th>
            </tr>
          </thead>
          <tbody id="trade-body"></tbody>
        </table>
      </div>
      <div class="summary">
        <span>Profit/loss on the last 150 contracts</span>
        <span class="total-profit" id="total-profit">+0.00</span>
      </div>
    </main>
  </div>

  <script>
    // ==== CONFIGURABLE: PNG logo links for the "Type" column ====
    window.TYPE_LOGOS = [
      "https://iili.io/KxDwyen.png",
      "https://iili.io/KxDOC4p.png"
    ];
    // =============================================================

    const tbody            = document.getElementById('trade-body');
    const totalProfitEl    = document.getElementById('total-profit');
    const scrollBox        = document.getElementById('scrollbox');
    const STORAGE_TRADES   = 'persistedTrades';
    const STORAGE_PROFIT   = 'persistedTotalProfit';
    const STORAGE_VERSION  = 'persistedVersion_v4_12mo_40to80_5kto8k'; // bump for new rules if reseeding

    let trades      = JSON.parse(localStorage.getItem(STORAGE_TRADES)) || [];
    let totalProfit = parseFloat(localStorage.getItem(STORAGE_PROFIT));
    if (isNaN(totalProfit)) totalProfit = 0;

    const fmtDate = d => new Intl.DateTimeFormat('en-GB', {
      day: '2-digit', month: 'short', year: 'numeric', timeZone: 'UTC'
    }).format(d);

    const fmtTime = d => new Intl.DateTimeFormat('en-GB', {
      hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', timeZone: 'UTC'
    }).format(d);

    function formatRefId() {
      let rest = '';
      for (let i = 0; i < 10; i++) rest += Math.floor(Math.random() * 10);
      return '14' + rest;
    }

    function pickLogo(customUrl) {
      if (customUrl) return customUrl;
      const list = Array.isArray(window.TYPE_LOGOS) && window.TYPE_LOGOS.length ? window.TYPE_LOGOS : [];
      if (!list.length) return '';
      return list[Math.floor(Math.random() * list.length)];
    }

    function rowHTML(data) {
      const buyDate  = data.buyTime ? new Date(data.buyTime)  : new Date();
      const sellDate = data.sellTime ? new Date(data.sellTime) : new Date();

      const cls  = data.profit >= 0 ? 'positive' : 'negative';
      const sign = data.profit >= 0 ? '+' : '';
      const refId = formatRefId();

      // **** UPDATED RULE: Contract Value always shows (stake + profit).
      // For losses (negative profit), this equals (stake - loss amount).
      const cv = (Number(data.stake||0) + Number(data.profit||0)).toFixed(2);

      const logo = pickLogo(data.logo);

      return `
        <tr data-profit="${Number(data.profit||0).toFixed(2)}">
          <td>
            <div class="type-wrap">
              <img class="type-logo" src="${logo}" alt="type-logo" />
            </div>
          </td>
          <td>${refId}</td>
          <td><span class="badge currency">USD</span></td>
          <td>${fmtDate(buyDate)}<br><span class="time">${fmtTime(buyDate)} GMT</span></td>
          <td>${Number(data.stake||0).toFixed(2)}</td>
          <td>${fmtDate(sellDate)}<br><span class="time">${fmtTime(sellDate)} GMT</span></td>
          <td>${cv}</td>
          <td class="${cls}">${sign}${Number(data.profit||0).toFixed(2)}</td>
        </tr>`;
    }

    function renderSavedTrades() {
      trades.slice().reverse().forEach(data => {
        tbody.insertAdjacentHTML('afterbegin', rowHTML(data));
      });
    }

    function formatSigned(n) {
      return (n >= 0 ? '+' : '') + Math.abs(n).toLocaleString('en-GB', {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      });
    }

    // Scroll-aware running total
    function updateRunningTotalOnScroll() {
      const rows = Array.from(tbody.querySelectorAll('tr'));
      const cutoff = scrollBox.scrollTop + scrollBox.clientHeight;
      let sum = 0;
      for (const tr of rows) {
        const top = tr.offsetTop;
        const mid = top + tr.offsetHeight / 2;
        if (mid <= cutoff) {
          sum += parseFloat(tr.dataset.profit || '0');
        } else {
          break;
        }
      }
      totalProfitEl.textContent = formatSigned(sum);
    }

    function updateTotalProfitDisplay() {
      totalProfitEl.textContent = formatSigned(totalProfit);
    }

    function addTrade(data) {
      data = {
        stake:  Number(data?.stake ?? 0),
        profit: Number(data?.profit ?? 0),
        buyTime: data?.buyTime || new Date().toISOString(),
        sellTime: data?.sellTime || new Date().toISOString(),
        logo: data?.logo || undefined
      };
      tbody.insertAdjacentHTML('afterbegin', rowHTML(data));
      totalProfit += data.profit;
      localStorage.setItem(STORAGE_PROFIT, totalProfit);
      trades.unshift(data);
      localStorage.setItem(STORAGE_TRADES, JSON.stringify(trades));
      updateRunningTotalOnScroll();
    }

    // ---------- SEEDER: last 12 months up to 2025-09-18 ----------
    (function maybeSeed() {
      const alreadySeeded = localStorage.getItem(STORAGE_VERSION) === '1';
      const urlForce = new URLSearchParams(location.search).get('forceSeed') === 'true';
      if (trades.length && alreadySeeded && !urlForce) {
        renderSavedTrades();
        updateRunningTotalOnScroll();
        return;
      }

      // Months: Oct 2024 .. Sep 2025 (Sep capped to 18th)
      const months = [];
      for (let y = 2024, m = 10; y < 2026; ) {
        months.push({ year: y, month: m }); // 1..12
        if (y === 2025 && m === 9) break;
        m++;
        if (m === 13) { m = 1; y++; }
      }

      function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }
      function randFloat(min, max){ return Math.random()*(max-min)+min; }

      function randomDateInMonth(year, month /*1-12*/) {
        const isSep2025 = (year === 2025 && month === 9);
        const lastDay   = isSep2025 ? 18 : new Date(year, month, 0).getDate();
        const day = randInt(1, lastDay);
        const hour = randInt(0, 21); // keep room for +2h
        const minute = randInt(0, 59);
        const second = randInt(0, 59);
        return new Date(Date.UTC(year, month-1, day, hour, minute, second));
      }

      const generated = [];

      months.forEach(({year, month}) => {
        const tradeCount = randInt(20, 30); // keep density
        const lossIndex  = randInt(0, tradeCount - 1); // exactly 1 loss per month

        for (let i=0; i<tradeCount; i++){
          const buy = randomDateInMonth(year, month);
          const durMin = randInt(30, 120); // 30min – 2h
          const sell = new Date(buy.getTime() + durMin*60*1000);

          const stake = Math.round(randFloat(5, 100)*100)/100;

          let profit;
          if (i === lossIndex) {
            // Small loss
            profit = -Math.round(randFloat(0.50, 2.50)*100)/100;
          } else {
            // Win must be between 40%–80% of stake
            const pMin = Math.max(0.40 * stake, 0.50);
            const pMax = 0.80 * stake;
            profit = Math.round(randFloat(pMin, pMax)*100)/100;
          }

          generated.push({
            stake,
            profit,
            buyTime: buy.toISOString(),
            sellTime: sell.toISOString(),
            logo: undefined
          });
        }
      });

      // —— Scale positives so TOTAL is within $5,000–$8,000 while keeping 40–80% rule ——
      const positives = generated.filter(t => t.profit > 0);
      const negatives = generated.filter(t => t.profit < 0);
      const sumPos0   = positives.reduce((s,t)=>s+t.profit,0);
      const sumNeg    = negatives.reduce((s,t)=>s+t.profit,0); // negative number
      const target    = (function(){ const x=Math.random(); return 5000 + x*(8000-5000); })();

      const candidate = (target - sumNeg) / Math.max(1e-6, sumPos0);

      let minFactor = -Infinity, maxFactor = Infinity;
      positives.forEach(t=>{
        const p0 = t.profit, s = t.stake;
        const lo = (0.40*s)/p0;
        const hi = (0.80*s)/p0;
        const fmin = Math.min(lo,hi), fmax = Math.max(lo,hi);
        minFactor = Math.max(minFactor, fmin);
        maxFactor = Math.min(maxFactor, fmax);
      });
      const factor = Math.min(Math.max(candidate, minFactor), maxFactor);

      positives.forEach(t=>{
        const s = t.stake;
        const p = t.profit * factor;
        const lo = Math.max(0.40*s, 0.50);
        const hi = 0.80*s;
        t.profit = Math.min(hi, Math.max(lo, Math.round(p*100)/100));
      });

      function tuneToward(targetTotal){
        let total = positives.reduce((s,t)=>s+t.profit,0) + sumNeg;
        let delta = Math.round((targetTotal - total)*100)/100;

        const maxIters = 3;
        for (let pass=0; pass<maxIters && Math.abs(delta) >= 0.02; pass++){
          if (delta > 0){
            let room = positives.reduce((s,t)=> s + (0.80*t.stake - t.profit), 0);
            if (room <= 0.01) break;
            positives.forEach(t=>{
              if (delta <= 0) return;
              const cap = Math.max(0, Math.floor(((0.80*t.stake - t.profit))*100)/100);
              if (cap <= 0) return;
              const add = Math.min(cap, Math.round((delta * (t.profit/Math.max(1e-6, sumPos0)))*100)/100 || 0.01);
              t.profit = Math.round((t.profit + add)*100)/100;
              delta = Math.round((delta - add)*100)/100;
            });
          } else {
            let room = positives.reduce((s,t)=> s + (t.profit - Math.max(0.40*t.stake, 0.50)), 0);
            if (room <= 0.01) break;
            positives.forEach(t=>{
              if (delta >= 0) return;
              const floor = Math.max(0.40*t.stake, 0.50);
              const cap = Math.max(0, Math.floor((t.profit - floor)*100)/100);
              if (cap <= 0) return;
              const cut = Math.min(cap, Math.round(((-delta) * (t.profit/Math.max(1e-6, sumPos0)))*100)/100 || 0.01);
              t.profit = Math.round((t.profit - cut)*100)/100;
              delta = Math.round((delta + cut)*100)/100;
            });
          }
          total = positives.reduce((s,t)=>s+t.profit,0) + sumNeg;
          delta = Math.round((targetTotal - total)*100)/100;
        }
      }
      tuneToward(target);

      generated.sort((a,b)=> new Date(b.buyTime) - new Date(a.buyTime));

      trades = generated.slice();
      totalProfit = trades.reduce((s,t)=>s+t.profit,0);

      localStorage.setItem(STORAGE_TRADES, JSON.stringify(trades));
      localStorage.setItem(STORAGE_PROFIT, totalProfit);
      localStorage.setItem(STORAGE_VERSION, '1');

      renderSavedTrades();
      updateRunningTotalOnScroll();
    })();
    // ---------------------------------------------------------------------

    // Update bottom total on scroll / load / resize
    scrollBox.addEventListener('scroll', updateRunningTotalOnScroll);
    window.addEventListener('load', () => setTimeout(updateRunningTotalOnScroll, 50));
    window.addEventListener('resize', updateRunningTotalOnScroll);

    // live channel appender (kept)
    const profitChannel = new BroadcastChannel('trade-profits');
    profitChannel.onmessage = ({ data }) => addTrade(data);

    /*
    // demo adder (disabled)
    setInterval(() => {
      const stake = 50 + Math.random()*50;
      const profit = Math.random() > 0.5
        ? +(Math.max(0.4*stake,0.5) + Math.random()*(0.8*stake - Math.max(0.4*stake,0.5))).toFixed(2)
        : -+(Math.random()*2 + 0.5).toFixed(2);
      addTrade({ stake, profit });
    }, 4000);
    */
  </script>
</body>
</html>
